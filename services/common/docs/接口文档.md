# Common 模块接口文档（API 参考）

## 目录
- [DataAccessFacade（统一入口）](#dataccessfacade统一入口)
- [UserService](#userservice)
- [AnchorService](#anchorservice)
- [AudienceService](#audienceservice)
- [LiveRoomService](#liveroomservice)
- [RechargeService](#rechargeservice)
- [SettlementService](#settlementservice)
- [CommissionRateService](#commissionrateservice)
- [WithdrawalService](#withdrawalservice)
- [SyncProgressService](#syncprogressservice)
- [异常类型](#异常类型)

---

## DataAccessFacade（统一入口）

### 概述
所有微服务通过此 Facade 访问 Common 模块的数据访问功能。这是唯一的访问入口。

### 方法列表

```java
// 获取 UserService
UserService user()

// 获取 AnchorService
AnchorService anchor()

// 获取 AudienceService
AudienceService audience()

// 获取 LiveRoomService
LiveRoomService liveRoom()

// 获取 RechargeService
RechargeService recharge()

// 获取 SettlementService
SettlementService settlement()

// 获取 CommissionRateService
CommissionRateService commissionRate()

// 获取 WithdrawalService
WithdrawalService withdrawal()

// 获取 SyncProgressService
SyncProgressService syncProgress()
```

### 使用示例

```java
@Autowired
private DataAccessFacade facade;

// 查询用户
public void getUserInfo(Long userId) {
    User user = facade.user().findById(userId);
}

// 查询主播
public void getAnchorInfo(Long anchorId) {
    Anchor anchor = facade.anchor().findById(anchorId);
}

// 查询充值
public void checkRecharge(String traceId) {
    Optional<Recharge> recharge = facade.recharge().findByTraceId(traceId);
}
```

---

## UserService

### 概述
用户数据访问服务。提供用户信息的 CRUD 操作。

### 方法列表

#### 1. findById(Long userId)
查询单个用户信息（缓存）

**签名**：
```java
@Cacheable(value = "user::id", key = "#userId")
@Transactional(readOnly = true)
User findById(Long userId)
```

**参数**：
- `userId`: 用户 ID

**返回**：
- User 对象，如果不存在返回 null

**缓存**：
- 缓存键：`user::id:#{userId}`
- 缓存时间：1 小时
- 更新用户时自动失效

**示例**：
```java
User user = facade.user().findById(123L);
System.out.println(user.getUsername());
```

---

#### 2. findByUsername(String username)
按用户名查询用户（缓存）

**签名**：
```java
@Cacheable(value = "user::username", key = "#username")
@Transactional(readOnly = true)
Optional<User> findByUsername(String username)
```

**参数**：
- `username`: 用户名

**返回**：
- Optional<User> 包装的用户对象，不存在返回 Optional.empty()

**缓存**：
- 缓存键：`user::username:#{username}`
- 缓存时间：1 小时

**示例**：
```java
Optional<User> user = facade.user().findByUsername("john_doe");
if (user.isPresent()) {
    System.out.println(user.get().getEmail());
}
```

---

#### 3. findByEmail(String email)
按邮箱查询用户

**签名**：
```java
@Transactional(readOnly = true)
Optional<User> findByEmail(String email)
```

**参数**：
- `email`: 邮箱地址

**返回**：
- Optional<User>

**缓存**：否

**示例**：
```java
Optional<User> user = facade.user().findByEmail("john@example.com");
```

---

#### 4. save(User user)
保存或更新单个用户

**签名**：
```java
@CacheEvict(value = {"user::id", "user::username", "user::email"}, allEntries = true)
@Transactional
User save(User user)
```

**参数**：
- `user`: User 对象

**返回**：
- 保存后的 User 对象（包含 ID）

**缓存失效**：
- 清除所有用户相关缓存

**事务**：
- 在事务中执行，失败自动回滚

**异常**：
- `IllegalArgumentException`: 用户信息不完整
- `DataIntegrityViolationException`: 违反数据库约束（如用户名重复）

**示例**：
```java
User user = new User();
user.setUsername("john_doe");
user.setEmail("john@example.com");
user.setPassword(hashPassword("password123"));
user.setUserType(1);
user.setStatus(1);
user.setCreateTime(LocalDateTime.now());

User savedUser = facade.user().save(user);
System.out.println(savedUser.getId());  // 返回自增 ID
```

---

#### 5. saveBatch(List<User> users)
批量保存用户

**签名**：
```java
@CacheEvict(value = {"user::id", "user::username", "user::email"}, allEntries = true)
@Transactional
List<User> saveBatch(List<User> users)
```

**参数**：
- `users`: User 列表

**返回**：
- 保存后的 User 列表

**缓存失效**：
- 清除所有用户缓存

**事务**：
- 批量操作自动分批：每 500 条一批
- 失败时全部回滚

**性能**：
- 10,000 条用户 → 20 批 → ~2 秒完成

**异常**：
- `IllegalArgumentException`: 列表为空或用户信息不完整

**示例**：
```java
List<User> users = new ArrayList<>();
for (int i = 0; i < 5000; i++) {
    User user = new User();
    user.setUsername("user_" + i);
    user.setEmail("user_" + i + "@example.com");
    // ... 其他字段
    users.add(user);
}

List<User> savedUsers = facade.user().saveBatch(users);
```

---

#### 6. deleteById(Long userId)
删除单个用户

**签名**：
```java
@CacheEvict(value = {"user::id", "user::username", "user::email"}, allEntries = true)
@Transactional
void deleteById(Long userId)
```

**参数**：
- `userId`: 用户 ID

**缓存失效**：
- 清除所有用户缓存

**异常**：
- 无（不存在也不报错）

**示例**：
```java
facade.user().deleteById(123L);
```

---

#### 7. findAll()
查询所有用户

**签名**：
```java
@Transactional(readOnly = true)
List<User> findAll()
```

**返回**：
- 所有用户的列表

**缓存**：否（可能数据量大）

**注意**：
- ⚠️ 谨慎使用，可能返回大量数据
- 建议添加分页

**示例**：
```java
List<User> allUsers = facade.user().findAll();
```

---

## AnchorService

### 概述
主播数据访问服务。提供主播信息查询、粉丝数/收入增减等操作。

### 方法列表

#### 1. findByUserId(Long userId)
查询主播信息（缓存）

**签名**：
```java
@Cacheable(value = "anchor::userId", key = "#userId")
@Transactional(readOnly = true)
Optional<Anchor> findByUserId(Long userId)
```

**参数**：
- `userId`: 用户 ID

**返回**：
- Optional<Anchor>

**缓存**：
- 缓存键：`anchor::userId:#{userId}`
- 缓存时间：1 小时

**示例**：
```java
Optional<Anchor> anchor = facade.anchor().findByUserId(123L);
if (anchor.isPresent()) {
    System.out.println(anchor.get().getFansCount());
}
```

---

#### 2. findTopAnchorsByFans(Integer limit)
查询粉丝最多的主播（排行榜）

**签名**：
```java
@Cacheable(value = "anchor::fans", key = "#limit")
@Transactional(readOnly = true)
List<Anchor> findTopAnchorsByFans(Integer limit)
```

**参数**：
- `limit`: 查询数量（通常为 10、100 等）

**返回**：
- 按粉丝数降序排列的主播列表

**缓存**：
- 缓存键：`anchor::fans:#{limit}`
- 缓存时间：1 小时

**示例**：
```java
// 获取粉丝最多的 10 个主播
List<Anchor> topAnchors = facade.anchor().findTopAnchorsByFans(10);
topAnchors.forEach(a -> System.out.println(a.getAnchorName() + ": " + a.getFansCount()));
```

---

#### 3. findTopAnchorsByEarnings(Integer limit)
查询收入最高的主播

**签名**：
```java
@Cacheable(value = "anchor::earnings", key = "#limit")
@Transactional(readOnly = true)
List<Anchor> findTopAnchorsByEarnings(Integer limit)
```

**参数**：
- `limit`: 查询数量

**返回**：
- 按收入降序排列的主播列表

**缓存**：
- 缓存键：`anchor::earnings:#{limit}`

**示例**：
```java
List<Anchor> richAnchors = facade.anchor().findTopAnchorsByEarnings(100);
```

---

#### 4. incrementFanCount(Long anchorId, int increment)
增加主播粉丝数

**签名**：
```java
@CacheEvict(value = "anchor::fans", allEntries = true)
@Transactional
void incrementFanCount(Long anchorId, int increment)
```

**参数**：
- `anchorId`: 主播 ID
- `increment`: 增加数量（正数）

**缓存失效**：
- 失效粉丝排行缓存

**事务**：
- 在事务中执行，失败回滚

**示例**：
```java
// 有新观众进入直播间
facade.anchor().incrementFanCount(456L, 1);
```

---

#### 5. incrementEarnings(Long anchorId, BigDecimal amount)
增加主播收入

**签名**：
```java
@CacheEvict(value = "anchor::earnings", allEntries = true)
@Transactional
void incrementEarnings(Long anchorId, BigDecimal amount)
```

**参数**：
- `anchorId`: 主播 ID
- `amount`: 增加金额

**缓存失效**：
- 失效收入排行缓存

**异常**：
- `IllegalArgumentException`: 金额为负数或为零

**示例**：
```java
// 观众赠送礼物，主播获得收入
BigDecimal giftAmount = new BigDecimal("99.99");
facade.anchor().incrementEarnings(456L, giftAmount);
```

---

#### 6. batchIncrementEarnings(Map<Long, BigDecimal> increments)
批量增加多个主播的收入

**签名**：
```java
@CacheEvict(value = "anchor::earnings", allEntries = true)
@Transactional
void batchIncrementEarnings(Map<Long, BigDecimal> increments)
```

**参数**：
- `increments`: 主播 ID → 增加金额的映射

**缓存失效**：
- 失效所有收入缓存

**事务**：
- 原子性：全部成功或全部失败

**性能**：
- 支持大批量更新（10,000+ 条记录）

**示例**：
```java
Map<Long, BigDecimal> increments = new HashMap<>();
increments.put(100L, new BigDecimal("50"));
increments.put(101L, new BigDecimal("100"));
increments.put(102L, new BigDecimal("75.5"));

facade.anchor().batchIncrementEarnings(increments);
```

---

## RechargeService

### 概述
充值数据访问服务。提供充值信息的 CRUD、幂等性检查（traceId）、聚合统计等操作。

### 方法列表

#### 1. findById(Long rechargeId)
查询单个充值记录

**签名**：
```java
@Transactional(readOnly = true)
Optional<Recharge> findById(Long rechargeId)
```

**参数**：
- `rechargeId`: 充值记录 ID

**返回**：
- Optional<Recharge>

**示例**：
```java
Optional<Recharge> recharge = facade.recharge().findById(789L);
```

---

#### 2. findByTraceId(String traceId) ⭐ 幂等性检查
查询充值记录（通过唯一标识符 traceId，用于幂等性检查）

**签名**：
```java
@Cacheable(value = "recharge::traceId", key = "#traceId")
@Transactional(readOnly = true)
Optional<Recharge> findByTraceId(String traceId)
```

**参数**：
- `traceId`: 唯一追踪 ID（通常是来自第三方支付的订单 ID）

**返回**：
- Optional<Recharge> 如果存在返回记录，不存在返回 Optional.empty()

**缓存**：
- 缓存键：`recharge::traceId:#{traceId}`
- 缓存时间：永久（或直到充值状态改变）

**用途**：
- 防止重复扣款（幂等性保证）
- 支付回调时必须先检查 traceId 是否已存在

**示例**：
```java
String traceId = "alipay_123456789";

// 支付回调时，先检查是否已处理
Optional<Recharge> existing = facade.recharge().findByTraceId(traceId);
if (existing.isPresent()) {
    // 已处理过，直接返回
    return existing.get();
}

// 未处理，创建新记录
Recharge recharge = new Recharge();
recharge.setAnchorId(456L);
recharge.setAmount(new BigDecimal("99.99"));
recharge.setTraceId(traceId);
recharge.setStatus(1);  // 已支付
recharge.setCreateTime(LocalDateTime.now());

facade.recharge().createRecharge(recharge);
```

---

#### 3. createRecharge(Recharge recharge) ⭐ 自动幂等性检查
创建充值记录（自动检查 traceId 防止重复）

**签名**：
```java
@CacheEvict(value = {"recharge::traceId", "recharge::anchor"}, allEntries = true)
@Transactional
Recharge createRecharge(Recharge recharge)
```

**参数**：
- `recharge`: Recharge 对象（必须包含 traceId）

**返回**：
- 保存后的 Recharge 对象

**缓存失效**：
- 清除 traceId 缓存
- 清除主播充值相关缓存

**事务**：
- 在事务中执行，失败回滚

**幂等性检查**：
- ✅ 自动检查 traceId 是否已存在
- ✅ 如已存在，抛出异常（通常捕获并返回已存在的记录）

**异常**：
- `DataIntegrityViolationException`: traceId 已存在（主键重复）
- `IllegalArgumentException`: 必要字段为空

**示例**：
```java
Recharge recharge = new Recharge();
recharge.setAnchorId(456L);
recharge.setAmount(new BigDecimal("99.99"));
recharge.setTraceId(UUID.randomUUID().toString());  // 使用 UUID 作为幂等键
recharge.setStatus(1);  // 已支付
recharge.setCreateTime(LocalDateTime.now());

try {
    Recharge saved = facade.recharge().createRecharge(recharge);
    log.info("充值创建成功: ID={}", saved.getRechargeId());
} catch (DataIntegrityViolationException e) {
    // traceId 已存在，可能是重复请求
    log.warn("充值 traceId 已存在: {}", recharge.getTraceId());
    Recharge existing = facade.recharge().findByTraceId(recharge.getTraceId()).get();
    return existing;
}
```

---

#### 4. sumRechargeAmountByAnchor(Long anchorId, LocalDate date)
统计主播某天的充值总额

**签名**：
```java
@Transactional(readOnly = true)
BigDecimal sumRechargeAmountByAnchor(Long anchorId, LocalDate date)
```

**参数**：
- `anchorId`: 主播 ID
- `date`: 日期

**返回**：
- 充值总额（BigDecimal），如无记录返回 BigDecimal.ZERO

**缓存**：否

**示例**：
```java
BigDecimal dailyIncome = facade.recharge()
    .sumRechargeAmountByAnchor(456L, LocalDate.now());
System.out.println("今日充值总额: " + dailyIncome);
```

---

#### 5. saveBatch(List<Recharge> recharges)
批量保存充值记录

**签名**：
```java
@CacheEvict(value = {"recharge::traceId", "recharge::anchor"}, allEntries = true)
@Transactional
List<Recharge> saveBatch(List<Recharge> recharges)
```

**参数**：
- `recharges`: Recharge 列表

**返回**：
- 保存后的 Recharge 列表

**缓存失效**：
- 清除所有充值缓存

**事务**：
- 自动分批（每 500 条）
- 批次内失败则该批次回滚，已提交的批次不回滚

**性能**：
- 50,000 条充值 → 100 批 → ~5 秒完成

**示例**：
```java
List<Recharge> recharges = new ArrayList<>();
for (int i = 0; i < 50000; i++) {
    Recharge r = new Recharge();
    r.setAnchorId(456L);
    r.setAmount(new BigDecimal("99.99"));
    r.setTraceId("trace_" + i);
    r.setStatus(1);
    r.setCreateTime(LocalDateTime.now());
    recharges.add(r);
}

facade.recharge().saveBatch(recharges);
```

---

## SettlementService

### 概述
结算数据访问服务。提供结算记录的管理和金额统计。

### 方法列表

#### 1. findById(Long settlementId)
查询单个结算记录

**签名**：
```java
@Transactional(readOnly = true)
Optional<Settlement> findById(Long settlementId)
```

#### 2. findAvailableByAnchor(Long anchorId)
查询主播可用结算记录

**签名**：
```java
@Transactional(readOnly = true)
List<Settlement> findAvailableByAnchor(Long anchorId)
```

**参数**：
- `anchorId`: 主播 ID

**返回**：
- 状态为"可用"的结算记录列表

#### 3. incrementAvailableAmount(Long anchorId, BigDecimal amount)
增加主播的可用结算金额

**签名**：
```java
@Transactional
void incrementAvailableAmount(Long anchorId, BigDecimal amount)
```

**参数**：
- `anchorId`: 主播 ID
- `amount`: 增加金额

#### 4. markAsSettled(Long settlementId)
标记结算为已结算

**签名**：
```java
@CacheEvict(value = "settlement::available", allEntries = true)
@Transactional
void markAsSettled(Long settlementId)
```

#### 5. sumAvailableAmountByAnchor(Long anchorId)
统计主播的总可用结算金额

**签名**：
```java
@Transactional(readOnly = true)
BigDecimal sumAvailableAmountByAnchor(Long anchorId)
```

**参数**：
- `anchorId`: 主播 ID

**返回**：
- 可用结算总额

**示例**：
```java
BigDecimal available = facade.settlement().sumAvailableAmountByAnchor(456L);
System.out.println("可用结算金额: " + available);
```

---

## CommissionRateService

### 概述
佣金率数据访问服务。提供佣金率的版本控制和历史记录查询。

### 方法列表

#### 1. findCurrentRateByAnchor(Long anchorId)
查询主播当前的佣金率

**签名**：
```java
@Cacheable(value = "commissionRate::current", key = "#anchorId")
@Transactional(readOnly = true)
Optional<CommissionRate> findCurrentRateByAnchor(Long anchorId)
```

**参数**：
- `anchorId`: 主播 ID

**返回**：
- 当前有效的佣金率记录

**缓存**：
- 缓存键：`commissionRate::current:#{anchorId}`

#### 2. findHistoryByAnchor(Long anchorId)
查询主播的佣金率历史

**签名**：
```java
@Transactional(readOnly = true)
List<CommissionRate> findHistoryByAnchor(Long anchorId)
```

**参数**：
- `anchorId`: 主播 ID

**返回**：
- 按时间倒序的佣金率变更历史

#### 3. createRate(CommissionRate rate)
创建新佣金率版本

**签名**：
```java
@CacheEvict(value = "commissionRate::current", allEntries = true)
@Transactional
CommissionRate createRate(CommissionRate rate)
```

**示例**：
```java
CommissionRate newRate = new CommissionRate();
newRate.setAnchorId(456L);
newRate.setRateValue(new BigDecimal("0.10"));  // 10% 佣金率
newRate.setEffectiveDate(LocalDate.now());
newRate.setStatus(1);  // 有效

facade.commissionRate().createRate(newRate);
```

---

## WithdrawalService

### 概述
提现数据访问服务。提供提现记录的管理（支持幂等性）。

### 方法列表

#### 1. findById(Long withdrawalId)
查询单个提现记录

**签名**：
```java
@Transactional(readOnly = true)
Optional<Withdrawal> findById(Long withdrawalId)
```

#### 2. findByTraceId(String traceId)
按 traceId 查询提现（幂等性检查）

**签名**：
```java
@Cacheable(value = "withdrawal::traceId", key = "#traceId")
@Transactional(readOnly = true)
Optional<Withdrawal> findByTraceId(String traceId)
```

#### 3. findPendingWithdrawals()
查询所有待处理提现

**签名**：
```java
@Transactional(readOnly = true)
List<Withdrawal> findPendingWithdrawals()
```

**返回**：
- 状态为"待处理"的提现列表

#### 4. save(Withdrawal withdrawal)
创建或更新提现记录

**签名**：
```java
@CacheEvict(value = {"withdrawal::pending", "withdrawal::traceId"}, allEntries = true)
@Transactional
Withdrawal save(Withdrawal withdrawal)
```

#### 5. updateStatus(Long withdrawalId, Integer status)
更新提现状态

**签名**：
```java
@CacheEvict(value = {"withdrawal::pending", "withdrawal::traceId"}, allEntries = true)
@Transactional
void updateStatus(Long withdrawalId, Integer status)
```

**参数**：
- `withdrawalId`: 提现 ID
- `status`: 新状态（0:待处理, 1:处理中, 2:已完成, 3:失败）

---

## SyncProgressService

### 概述
同步进度数据访问服务。用于跟踪微服务间数据同步的进度。

### 方法列表

#### 1. findById(Long progressId)
查询单个同步进度记录

**签名**：
```java
@Transactional(readOnly = true)
Optional<SyncProgress> findById(Long progressId)
```

#### 2. findBySyncType(Integer syncType)
按同步类型查询进度

**签名**：
```java
@Cacheable(value = "syncProgress::syncType", key = "#syncType")
@Transactional(readOnly = true)
List<SyncProgress> findBySyncType(Integer syncType)
```

#### 3. findByService(String sourceService, String targetService)
按源/目标服务查询

**签名**：
```java
@Cacheable(value = "syncProgress::service", key = "#sourceService + '_' + #targetService")
@Transactional(readOnly = true)
Optional<SyncProgress> findByService(String sourceService, String targetService)
```

#### 4. findPendingSync()
查询所有待同步的进度

**签名**：
```java
@Cacheable(value = "syncProgress::pending")
@Transactional(readOnly = true)
List<SyncProgress> findPendingSync()
```

#### 5. findSyncNeedRetry()
查询需要重试的同步

**签名**：
```java
@Transactional(readOnly = true)
List<SyncProgress> findSyncNeedRetry()
```

#### 6. createSyncProgress(SyncProgress progress)
创建同步进度记录

**签名**：
```java
@CacheEvict(value = {"syncProgress::syncType", "syncProgress::service", "syncProgress::pending"}, allEntries = true)
@Transactional
SyncProgress createSyncProgress(SyncProgress progress)
```

#### 7. updateSyncStatus(Long progressId, Integer status)
更新同步状态

**签名**：
```java
@CacheEvict(value = {"syncProgress::pending", "syncProgress::status"}, allEntries = true)
@Transactional
void updateSyncStatus(Long progressId, Integer status)
```

**参数**：
- `progressId`: 进度 ID
- `status`: 新状态（0:待同步, 1:同步中, 2:已同步, 3:失败）

#### 8. markAsFailed(Long progressId, String errorMessage)
标记同步失败

**签名**：
```java
@CacheEvict(value = {"syncProgress::pending", "syncProgress::failed"}, allEntries = true)
@Transactional
void markAsFailed(Long progressId, String errorMessage)
```

#### 9. batchSave(List<SyncProgress> progresses)
批量保存同步进度

**签名**：
```java
@CacheEvict(value = {"syncProgress::syncType", "syncProgress::service", "syncProgress::pending"}, allEntries = true)
@Transactional
List<SyncProgress> batchSave(List<SyncProgress> progresses)
```

---

## 异常类型

### 常见异常

| 异常类型 | 说明 | 常见原因 |
|---------|------|---------|
| `IllegalArgumentException` | 参数不合法 | 必要参数为 null、空列表 |
| `DataIntegrityViolationException` | 数据库约束违反 | traceId 重复、username 重复 |
| `OptimisticLockingFailureException` | 乐观锁冲突 | 并发更新同一记录 |
| `TransactionException` | 事务异常 | 超时、死锁 |
| `EntityNotFoundException` | 实体不存在 | 查询 ID 不存在 |

### 异常处理示例

```java
try {
    Recharge recharge = new Recharge();
    // ... 设置字段
    recharge.setTraceId(traceId);
    
    facade.recharge().createRecharge(recharge);
} catch (DataIntegrityViolationException e) {
    // traceId 已存在，可能是重复请求
    Optional<Recharge> existing = facade.recharge().findByTraceId(traceId);
    if (existing.isPresent()) {
        return existing.get();  // 幂等性处理：返回已存在的记录
    }
} catch (IllegalArgumentException e) {
    // 参数不合法
    log.error("参数验证失败: {}", e.getMessage());
    throw new BusinessException("请求参数不正确");
} catch (Exception e) {
    // 其他异常
    log.error("系统异常", e);
    throw new SystemException("系统异常");
}
```

---

## 版本历史

| 版本 | 日期 | 主要变化 |
|------|------|---------|
| 2.0 | 2026-01-07 | 整合所有 API 文档，统一格式 |
| 1.0 | 2026-01-06 | 初始版本 |
