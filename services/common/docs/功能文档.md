# Common 模块功能文档

## 目录
1. [模块概述](#模块概述)
2. [架构设计](#架构设计)
3. [核心组件](#核心组件)
4. [缓存策略](#缓存策略)
5. [批量操作](#批量操作)
6. [事务管理](#事务管理)
7. [使用场景](#使用场景)

---

## 模块概述

Common 模块是整个微服务系统的数据访问层。它提供统一的数据读写接口，确保：
- **数据一致性**：所有微服务通过统一入口访问数据
- **自动缓存**：使用 Redis 缓存提高性能
- **批量操作**：支持大批量数据处理，自动分批
- **幂等性控制**：通过 traceId 防止重复操作
- **事务管理**：统一事务控制和回滚策略

### 关键统计
- **核心数据表**：14 个表
- **数据库**：2 个（live_audience_db、live_finance_db）
- **Service 类**：9 个
- **Repository 接口**：9 个
- **缓存时间**：1 小时（可配置）

---

## 架构设计

### 三层架构

```
┌─────────────────────────────────┐
│    其他微服务（Anchor、Finance等）   │
└──────────────┬──────────────────┘
               │ 调用
┌──────────────▼──────────────────┐
│  DataAccessFacade（统一入口）      │  ◄─── 单一访问点
│  facade.user(), facade.anchor()  │
└──────────────┬──────────────────┘
               │
┌──────────────▼──────────────────┐
│      Service 层（业务逻辑）        │
│  - 自动缓存（@Cacheable）         │
│  - 缓存失效（@CacheEvict）        │
│  - 批量操作分批                  │
│  - 事务管理                      │
└──────────────┬──────────────────┘
               │
┌──────────────▼──────────────────┐
│   BaseService（基础服务）         │
│  - 通用 CRUD 操作               │
│  - 批量操作逻辑                 │
│  - 缓存字段定义                 │
└──────────────┬──────────────────┘
               │
┌──────────────▼──────────────────┐
│    Repository 层（数据访问）      │
│  - JPA 查询接口                 │
│  - 业务特定查询                 │
└──────────────┬──────────────────┘
               │
┌──────────────▼──────────────────┐
│      Hibernate + Spring Data     │
│           MySQL 数据库           │
└─────────────────────────────────┘
```

### 设计模式

1. **Repository 模式**
   - 提供数据访问的通用接口
   - 屏蔽底层数据源实现
   - 支持切换存储引擎（如从 MySQL 切换到 PostgreSQL）

2. **Service 模式**
   - 包含业务逻辑和事务管理
   - 实现自动缓存策略
   - 处理批量操作分批逻辑

3. **Facade 模式**
   - 统一数据访问入口
   - 简化客户端集成
   - 便于全局监控和日志

---

## 核心组件

### 1. DataAccessFacade（统一入口）

所有微服务必须通过此 Facade 访问数据，**禁止直接使用 Repository 或 Mapper**。

```java
@Autowired
private DataAccessFacade facade;

// 访问用户数据
facade.user().findById(userId);
facade.user().saveBatch(userList);

// 访问主播数据
facade.anchor().findByUserId(userId);
facade.anchor().incrementFanCount(anchorId);

// 访问充值数据
facade.recharge().findByTraceId(traceId);
```

**Facade 包含的服务**：
- `user()` - UserService
- `anchor()` - AnchorService
- `audience()` - AudienceService
- `liveRoom()` - LiveRoomService
- `recharge()` - RechargeService
- `settlement()` - SettlementService
- `commissionRate()` - CommissionRateService
- `withdrawal()` - WithdrawalService
- `syncProgress()` - SyncProgressService

### 2. BaseService（基础服务）

所有 Service 都继承 BaseService，获得通用功能：

```java
public abstract class BaseService<T, ID, R extends JpaRepository<T, ID>> {
    protected R repository;
    
    // 通用 CRUD 操作
    public T findById(ID id) { }
    public List<T> findAll() { }
    public T save(T entity) { }
    public List<T> saveBatch(List<T> entities) { }
    public void delete(ID id) { }
    public void deleteBatch(List<ID> ids) { }
    
    // 缓存操作
    @Cacheable(...)
    protected List<T> getCachedList(...) { }
    
    // 事务操作
    @Transactional
    protected void executeInTransaction(...) { }
}
```

### 3. Service 实现类

每个 Service 提供特定实体的业务操作：

#### UserService
- `findById(Long userId)` - 查询用户（缓存）
- `findByUsername(String username)` - 按用户名查询
- `save(User user)` - 保存用户
- `saveBatch(List<User> users)` - 批量保存
- `updateUserStatus(Long userId, Integer status)` - 更新用户状态

#### AnchorService
- `findByUserId(Long userId)` - 查询主播信息（缓存）
- `findTopAnchorsByFans(Integer limit)` - 查询粉丝最多的主播
- `incrementFanCount(Long anchorId, int increment)` - 增加粉丝数
- `incrementEarnings(Long anchorId, BigDecimal amount)` - 增加收入
- `batchIncrementEarnings(Map<Long, BigDecimal> increments)` - 批量增加收入

#### RechargeService（幂等性控制）
- `createRecharge(Recharge recharge)` - 创建充值（检查 traceId 防重）
- `findByTraceId(String traceId)` - 查询充值（缓存）
- `sumRechargeAmountByAnchor(Long anchorId, LocalDate date)` - 聚合统计
- `batchSave(List<Recharge> recharges)` - 批量保存

#### SettlementService
- `findAvailable(Long anchorId)` - 查询可用结算记录
- `incrementAvailableAmount(Long anchorId, BigDecimal amount)` - 增加可用金额
- `markAsSettled(Long settlementId)` - 标记为已结算
- `sumAvailableAmountByAnchor(Long anchorId)` - 统计可用金额

#### CommissionRateService（版本控制）
- `findCurrentRateByAnchor(Long anchorId)` - 查询当前佣金率
- `findHistoryByAnchor(Long anchorId)` - 查询历史佣金率
- `createRate(CommissionRate rate)` - 创建新佣金率版本

### 4. Repository 接口

定义数据查询逻辑，使用 JPA 注解：

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u FROM User u WHERE u.username = :username")
    Optional<User> findByUsername(@Param("username") String username);
    
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmail(@Param("email") String email);
    
    @Query("SELECT u FROM User u WHERE u.userType = :type AND u.status = 1")
    List<User> findActiveUsersByType(@Param("type") Integer type);
}
```

---

## 缓存策略

### 缓存工作流程

```
┌─────────────────┐
│  调用 Service   │
│  的查询方法      │
└────────┬────────┘
         │
     ┌───▼────┐
     │  检查   │
     │ Redis? │
     └───┬────┘
         │
    ┌────┴────────────────────┐
    │ 命中                 未命中  │
    ▼                         ▼
┌────────┐          ┌────────────────┐
│返回    │          │查询数据库       │
│缓存    │          │并存入 Redis    │
│数据    │          │设置过期时间    │
└────────┘          └────────────────┘
                           │
                           ▼
                    ┌────────────────┐
                    │返回数据         │
                    └────────────────┘
```

### 缓存配置

**缓存时间**：1 小时（3600 秒）
**缓存前缀**：实体名称 + 查询条件

**常用缓存键**：
```
user::id -> 用户信息缓存
anchor::fans -> 粉丝排行缓存
anchor::earnings -> 收入排行缓存
recharge::traceId -> 充值幂等性检查缓存
```

### 缓存失效时机

**执行以下操作时，相关缓存自动失效**：

1. **保存操作** (`save()`, `saveBatch()`)
   - 失效: 相关实体的所有缓存

2. **更新操作** (`update*()`)
   - 失效: 被更新实体的缓存

3. **删除操作** (`delete()`, `deleteBatch()`)
   - 失效: 相关实体的所有缓存

**示例**：
```java
// 保存用户时，自动失效所有用户缓存
@CacheEvict(value = "user", allEntries = true)
@Transactional
public User save(User user) { }
```

---

## 批量操作

### 批处理机制

系统会自动将大批量操作分成小批次处理，**每批 500 条数据**。

### 工作流程

```
输入: 10,000 条记录
         │
         ▼
分批逻辑（BATCH_SIZE=500）
         │
    ┌────┴────────────────────────┐
    │                              │
    ▼                              ▼
┌──────────┐                ┌──────────┐
│ 批次 1   │ ... ... ...     │ 批次 20  │
│ 500 条   │                │ 500 条   │
└──────────┘                └──────────┘
    │                              │
    └────────────────┬─────────────┘
                     │
                     ▼
          ┌────────────────────┐
          │ 执行数据库操作     │
          │ （自动转换，      │
          │  逐批提交）       │
          └────────────────────┘
```

### 使用示例

```java
// 批量保存 10,000 条充值记录
List<Recharge> recharges = new ArrayList<>();
for (int i = 0; i < 10000; i++) {
    recharges.add(new Recharge(...));
}

// 自动分批，BaseService 会分 20 批处理
facade.recharge().saveBatch(recharges);
```

### 性能影响

- **无分批**：10,000 条记录一次性提交 → SQL 过大 → 超时
- **分批处理**：每 500 条一批 → 生成 20 条 INSERT 语句 → 更快完成

---

## 事务管理

### 事务边界

**所有写操作默认在事务中执行**：

```java
@Transactional
public User save(User user) {
    return repository.save(user);
}

@Transactional
public List<User> saveBatch(List<User> users) {
    // 批量操作：全部成功则提交，任何失败则全部回滚
    return repository.saveAll(users);
}
```

### 事务隔离级别

**默认隔离级别**：REPEATABLE_READ（可重复读）
- 防止脏读、不可重复读
- 可能发生幻读（通常可接受）

### 事务超时

**默认超时**：30 秒
- 对于大批量操作，可在 Service 方法上指定：

```java
@Transactional(timeout = 120)  // 120 秒超时
public List<Recharge> batchImport(List<Recharge> recharges) {
    return repository.saveAll(recharges);
}
```

### 手动事务管理

某些复杂场景需要手动管理事务：

```java
@Transactional
public void complexOperation() {
    try {
        // 操作 1
        User user = facade.user().save(userA);
        
        // 操作 2
        Anchor anchor = facade.anchor().save(anchorB);
        
        // 如果任何操作失败，整个事务回滚
    } catch (Exception e) {
        // 事务自动回滚
        log.error("操作失败", e);
        throw new BusinessException("操作失败");
    }
}
```

---

## 使用场景

### 场景 1：用户注册（单个对象）

```java
public void registerUser(UserRegisterDTO dto) {
    // 检查用户名是否已存在
    Optional<User> existing = facade.user().findByUsername(dto.getUsername());
    if (existing.isPresent()) {
        throw new BusinessException("用户名已存在");
    }
    
    // 创建用户（自动缓存）
    User user = new User();
    user.setUsername(dto.getUsername());
    user.setEmail(dto.getEmail());
    user.setPassword(hashPassword(dto.getPassword()));
    user.setUserType(1);  // 普通用户
    user.setStatus(1);    // 启用
    user.setCreateTime(LocalDateTime.now());
    
    facade.user().save(user);
}
```

**涉及的缓存失效**：
- 用户名索引缓存失效
- 用户列表缓存失效

---

### 场景 2：主播数据实时更新（原子性）

```java
// 直播间有人赠送礼物
public void giftReceived(Long anchorId, BigDecimal amount) {
    // 增加主播粉丝数（实际应该是观众数）
    facade.anchor().incrementFanCount(anchorId, 1);
    
    // 增加主播收入
    facade.anchor().incrementEarnings(anchorId, amount);
    
    // 创建充值记录（防重复）
    Recharge recharge = new Recharge();
    recharge.setAnchorId(anchorId);
    recharge.setAmount(amount);
    recharge.setTraceId(UUID.randomUUID().toString());  // 幂等键
    recharge.setCreateTime(LocalDateTime.now());
    
    facade.recharge().createRecharge(recharge);
}
```

**保证**：
- 粉丝数+1、收入增加、充值记录创建 全部成功或全部失败
- 即使系统崩溃，traceId 保证不会重复扣款

---

### 场景 3：批量数据导入（大批量）

```java
// 导入 50,000 条历史充值数据
public void importRechargeHistory(List<RechargeImportDTO> dtos) {
    List<Recharge> recharges = dtos.stream()
        .map(dto -> {
            Recharge r = new Recharge();
            r.setAnchorId(dto.getAnchorId());
            r.setAmount(dto.getAmount());
            r.setTraceId(dto.getOriginalId());  // 用原始 ID 作为幂等键
            r.setCreateTime(dto.getCreateTime());
            return r;
        })
        .collect(Collectors.toList());
    
    // 自动分批：50,000 条 / 500 = 100 批
    long startTime = System.currentTimeMillis();
    facade.recharge().saveBatch(recharges);
    long duration = System.currentTimeMillis() - startTime;
    
    log.info("导入完成: 共 {} 条, 耗时 {} ms", recharges.size(), duration);
}
```

**性能**：
- 100 批 × 预计每批 50ms = ~5 秒完成
- 比一次性导入快 10 倍以上

---

### 场景 4：复杂统计查询（聚合）

```java
// 统计主播日收入排行
public List<AnchorIncomeDTO> getTopAnchorsByDailyIncome(LocalDate date) {
    // 获取收入排行前 100 的主播（缓存）
    List<Anchor> topAnchors = facade.anchor()
        .findTopAnchorsByEarnings(100);
    
    // 为每个主播统计当日收入
    List<AnchorIncomeDTO> result = topAnchors.stream()
        .map(anchor -> {
            BigDecimal dailyIncome = facade.recharge()
                .sumRechargeAmountByAnchor(anchor.getAnchorId(), date);
            
            return AnchorIncomeDTO.builder()
                .anchorId(anchor.getAnchorId())
                .anchorName(anchor.getAnchorName())
                .dailyIncome(dailyIncome)
                .totalEarnings(anchor.getTotalEarnings())
                .fansCount(anchor.getFansCount())
                .build();
        })
        .sorted(Comparator.comparing(AnchorIncomeDTO::getDailyIncome).reversed())
        .collect(Collectors.toList());
    
    return result;
}
```

**缓存命中**：
- 前 100 主播信息从 Redis 直接获取
- 无需查询数据库

---

### 场景 5：金融数据结算（事务一致性）

```java
// 主播提现
@Transactional
public Withdrawal submitWithdrawal(Long anchorId, BigDecimal amount) {
    // 1. 检查可用结算余额
    BigDecimal available = facade.settlement()
        .sumAvailableAmountByAnchor(anchorId);
    
    if (available.compareTo(amount) < 0) {
        throw new BusinessException("结算余额不足");
    }
    
    // 2. 扣减可用金额
    facade.settlement().decrementAvailableAmount(anchorId, amount);
    
    // 3. 创建提现记录（防重复）
    Withdrawal withdrawal = new Withdrawal();
    withdrawal.setAnchorId(anchorId);
    withdrawal.setAmount(amount);
    withdrawal.setTraceId(UUID.randomUUID().toString());
    withdrawal.setStatus(0);  // 待处理
    withdrawal.setCreateTime(LocalDateTime.now());
    
    Withdrawal saved = facade.withdrawal().save(withdrawal);
    
    // 4. 记录同步进度
    facade.syncProgress().createSyncProgress(
        SyncProgress.builder()
            .sourceService("audience")
            .targetService("finance")
            .syncType(3)  // 提现同步
            .build()
    );
    
    return saved;
}
```

**事务保证**：
- 金额检查、扣减、创建记录、记录同步 全部原子性完成
- 如失败，自动回滚所有更改

---

## 常见问题

### Q1：为什么必须使用 DataAccessFacade？
**A**：
- 确保全局的缓存一致性
- 便于监控所有数据库操作
- 便于实现全局的分析和限流
- 防止开发者绕过业务逻辑层

### Q2：缓存过期后会怎样？
**A**：自动从数据库重新加载，再存入 Redis

### Q3：大批量操作会很慢吗？
**A**：不会。批处理分批提交，每批只有 500 条，速度很快

### Q4：如何保证数据一致性？
**A**：通过事务、幂等性检查（traceId）、缓存失效机制

### Q5：能直接修改 SQL 查询吗？
**A**：不建议。应该在 Repository 中添加新的 @Query 方法，然后在 Service 中暴露

---

## 最佳实践

1. **始终使用 Facade**
   ```java
   // ✅ 正确
   facade.user().findById(1L);
   
   // ❌ 错误
   userRepository.findById(1L);
   ```

2. **合理利用缓存**
   - 查询大量数据时，优先使用带缓存的方法
   - 频繁更新的数据，考虑缓存时间较短

3. **正确处理幂等性**
   ```java
   // 充值、提现等操作必须有 traceId
   recharge.setTraceId(UUID.randomUUID().toString());
   ```

4. **使用批量操作**
   ```java
   // ✅ 正确：1 次批量操作
   facade.user().saveBatch(userList);
   
   // ❌ 错误：10,000 次循环调用
   for (User u : userList) {
       facade.user().save(u);
   }
   ```

5. **正确处理异常**
   ```java
   try {
       facade.user().save(user);
   } catch (DataIntegrityViolationException e) {
       // 违反约束条件
       throw new BusinessException("用户名已存在");
   } catch (Exception e) {
       // 其他异常
       log.error("保存用户失败", e);
       throw new SystemException("系统异常");
   }
   ```

---

## 版本历史

| 版本 | 日期 | 主要变化 |
|------|------|---------|
| 2.0 | 2026-01-07 | 整合文档，删除过期文档 |
| 1.0 | 2026-01-06 | 初始版本，包含 Repository+Service 架构 |
