# 数据分析模块设计文档

## 更新日期：2026-01-02

---

## 一、数据分析目标

### 1.1 核心分析维度

#### 财务维度
- 主播收入分析（日/周/月/年）
- 观众消费分析（消费分层、LTV预测）
- 平台流水分析（趋势预测、异常检测）
- 分成结算分析（分成比例效果评估）

#### 用户维度
- 观众画像分析（消费能力、活跃度、偏好）
- 主播画像分析（收入能力、粉丝质量、直播质量）
- 用户留存分析（次日/7日/30日留存）
- 用户流失预警（流失概率预测）

#### 内容维度
- 标签热力图分析（标签关联度、热门标签）
- 直播间质量分析（观众互动、打赏转化率）
- 分类效果分析（不同分类的收入表现）
- 时段分析（高峰时段、最佳直播时间）

---

## 二、图表类型与应用场景

### 2.1 时序图表

#### 1. 折线图 (Line Chart)
**应用场景**：
- 平台总流水趋势（日/周/月）
- 主播收入趋势
- 观众消费趋势
- 活跃用户数趋势

**数据源**：
- `hourly_statistics` (小时统计)
- `recharge_record` (打赏记录)
- `settlement_detail` (结算明细)

#### 2. 面积图 (Area Chart)
**应用场景**：
- 累计收入对比（多个主播对比）
- 分类占比趋势
- 堆叠展示不同收入来源

#### 3. 柱状图 (Bar Chart)
**应用场景**：
- 主播收入TOP10
- 观众消费TOP10
- 每日/每周/每月对比
- 时段分布

---

### 2.2 分布图表

#### 4. 饼图 / 环形图 (Pie / Donut Chart)
**应用场景**：
- 观众消费等级分布
- 主播分类占比
- 收入来源占比
- 性别分布

#### 5. 漏斗图 (Funnel Chart)
**应用场景**：
- 观众转化漏斗：访问 → 注册 → 打赏 → 复购
- 主播成长漏斗：注册 → 首播 → 获得打赏 → 稳定收入

#### 6. 散点图 (Scatter Chart)
**应用场景**：
- 观众消费能力 vs 活跃度
- 主播收入 vs 粉丝数
- 打赏金额 vs 打赏频次

---

### 2.3 热力图

#### 7. 标签热力图 (Tag Heatmap)
**应用场景**：
- 标签关联度矩阵
- 标签共现频率
- 推荐标签组合

**数据源**：
- `tag_relation` (标签关联度表)
- `anchor_tag` / `audience_tag` (标签关联表)

#### 8. 时间热力图 (Time Heatmap)
**应用场景**：
- 一周内每小时的打赏活跃度
- 主播直播时段分布
- 观众在线时段分布

---

### 2.4 高级图表

#### 9. 雷达图 (Radar Chart)
**应用场景**：
- 主播多维度评估（收入、粉丝、互动、稳定性、增长）
- 观众画像（消费、活跃、留存、偏好、忠诚度）

#### 10. 桑基图 (Sankey Diagram)
**应用场景**：
- 资金流向：观众 → 平台 → 主播
- 用户流转：新用户 → 活跃 → 流失 / 留存

#### 11. 箱线图 (Box Plot)
**应用场景**：
- 主播收入分布（中位数、四分位数、异常值）
- 观众消费分布

---

## 三、核心分析指标与计算公式

### 3.1 财务指标

#### 1. 平台总流水 (GMV)
```
GMV = Σ recharge_amount
时间范围：日/周/月/年
```

#### 2. 平台实际收入
```
平台收入 = Σ (recharge_amount × (1 - commission_rate))
```

#### 3. 主播实际收入
```
主播收入 = Σ (recharge_amount × commission_rate)
```

#### 4. ARPU (Average Revenue Per User)
```
ARPU = 总收入 / 付费用户数
```

#### 5. ARPPU (Average Revenue Per Paying User)
```
ARPPU = 总收入 / 付费用户数
```

#### 6. 付费率
```
付费率 = 付费用户数 / 总用户数 × 100%
```

#### 7. 复购率
```
复购率 = 多次付费用户数 / 总付费用户数 × 100%
```

---

### 3.2 主播收入分析指标

#### 1. 主播日/周/月收入
```sql
SELECT 
    anchor_id,
    anchor_name,
    DATE(recharge_time) as date,
    SUM(recharge_amount * applied_commission_rate / 100) as income,
    COUNT(*) as recharge_count,
    COUNT(DISTINCT audience_id) as unique_payers
FROM recharge_record
WHERE recharge_time BETWEEN '开始时间' AND '结束时间'
GROUP BY anchor_id, DATE(recharge_time)
ORDER BY income DESC
```

#### 2. 主播收入稳定性（变异系数 CV）
```
CV = 标准差 / 平均值
CV < 0.3: 收入稳定
0.3 ≤ CV < 0.5: 收入一般
CV ≥ 0.5: 收入波动大

标准差 σ = √(Σ(xi - μ)² / n)
平均值 μ = Σxi / n
```

#### 3. 主播收入增长率
```
周增长率 = (本周收入 - 上周收入) / 上周收入 × 100%
月增长率 = (本月收入 - 上月收入) / 上月收入 × 100%

环比增长率 = (当期 - 上期) / 上期 × 100%
同比增长率 = (当期 - 去年同期) / 去年同期 × 100%
```

#### 4. 主播人均粉丝价值 (Fan Value)
```
粉丝价值 = 主播总收入 / 粉丝数
```

#### 5. 主播打赏转化率
```
打赏转化率 = 打赏观众数 / 总观看人次 × 100%
```

---

### 3.3 观众消费分析指标

#### 1. 观众消费分层 (RFM模型)

**R (Recency) - 最近一次消费**
```
R_score = 
    5分: 最近7天内消费
    4分: 8-14天
    3分: 15-30天
    2分: 31-60天
    1分: 60天以上
```

**F (Frequency) - 消费频次**
```
F_score = 
    5分: 消费次数 >= 20
    4分: 10-19次
    3分: 5-9次
    2分: 2-4次
    1分: 1次
```

**M (Monetary) - 消费金额**
```
M_score = 
    5分: 累计消费 >= P80 (前20%)
    4分: P60 - P80
    3分: P40 - P60
    2分: P20 - P40
    1分: < P20 (后20%)
```

**综合评分**
```
RFM综合得分 = R_score × 0.3 + F_score × 0.3 + M_score × 0.4

高价值用户: RFM >= 4.0
中价值用户: 3.0 <= RFM < 4.0
低价值用户: RFM < 3.0
```

#### 2. 观众消费分位数计算
```sql
-- 计算观众消费分位数
SELECT 
    audience_id,
    total_recharge_amount,
    PERCENT_RANK() OVER (ORDER BY total_recharge_amount) * 100 as percentile,
    CASE 
        WHEN PERCENT_RANK() OVER (ORDER BY total_recharge_amount) >= 0.8 THEN 2  -- 高消费(前20%)
        WHEN PERCENT_RANK() OVER (ORDER BY total_recharge_amount) >= 0.2 THEN 1  -- 中消费(20%-80%)
        ELSE 0  -- 低消费(后20%)
    END as consumption_level
FROM audience
```

#### 3. 观众生命周期价值 (LTV预测)

**历史LTV**
```
LTV_历史 = 累计消费金额
```

**预测LTV (线性回归)**
```
LTV_预测 = α + β₁ × 消费频次 + β₂ × 平均单笔金额 + β₃ × 留存天数 + β₄ × 活跃度

其中：
- α: 截距
- β₁, β₂, β₃, β₄: 回归系数（通过历史数据训练）
```

**简化预测公式**
```
LTV_简化 = ARPPU × 平均消费频次 × 预期留存月数

预期留存月数 ≈ 1 / 月流失率
```

#### 4. 观众活跃度评分
```
活跃度 = w₁ × 打赏频次归一化 + w₂ × 观看时长归一化 + w₃ × 互动次数归一化

归一化公式: (x - min) / (max - min)
权重: w₁=0.4, w₂=0.3, w₃=0.3

活跃度等级:
- 高活跃: score >= 0.7
- 中活跃: 0.4 <= score < 0.7
- 低活跃: score < 0.4
```

---

### 3.4 标签热力图算法

#### 1. 标签关联度计算 (Jaccard相似度)
```
Jaccard(A, B) = |A ∩ B| / |A ∪ B|

其中：
- A: 拥有标签A的用户集合
- B: 拥有标签B的用户集合
- |A ∩ B|: 同时拥有A和B标签的用户数
- |A ∪ B|: 拥有A或B标签的用户数

关联度评分 = Jaccard × 100
```

#### 2. 标签共现频率 (Co-occurrence)
```
共现频率 = 同时出现次数 / MIN(标签A总次数, 标签B总次数)
```

#### 3. 标签关联强度等级
```
关联强度 = 
    强关联: Jaccard >= 0.5 或 共现频率 >= 0.6
    中关联: 0.3 <= Jaccard < 0.5 或 0.4 <= 共现频率 < 0.6
    弱关联: Jaccard < 0.3 或 共现频率 < 0.4
```

#### 4. 标签热力图矩阵生成
```
热力图矩阵 H[i][j] = 标签i与标签j的关联度评分

对称矩阵: H[i][j] = H[j][i]
对角线: H[i][i] = 100 (自身完全关联)
```

**SQL示例**
```sql
-- 计算标签关联度
SELECT 
    t1.tag_id as tag_id1,
    t2.tag_id as tag_id2,
    COUNT(*) as cooccurrence_count,
    ROUND(
        COUNT(*) * 100.0 / 
        (SELECT COUNT(DISTINCT user_id) FROM user_tag WHERE tag_id IN (t1.tag_id, t2.tag_id)),
        2
    ) as relation_score
FROM 
    (SELECT DISTINCT user_id, tag_id FROM anchor_tag
     UNION ALL
     SELECT DISTINCT user_id, tag_id FROM audience_tag) t1
INNER JOIN 
    (SELECT DISTINCT user_id, tag_id FROM anchor_tag
     UNION ALL
     SELECT DISTINCT user_id, tag_id FROM audience_tag) t2
ON t1.user_id = t2.user_id AND t1.tag_id < t2.tag_id
GROUP BY t1.tag_id, t2.tag_id
HAVING cooccurrence_count >= 10  -- 至少共现10次
ORDER BY relation_score DESC
```

---

### 3.5 流水变化趋势分析

#### 1. 移动平均 (Moving Average)
```
MA_n = (x₁ + x₂ + ... + xₙ) / n

MA_7: 7日移动平均（周均值）
MA_30: 30日移动平均（月均值）
```

#### 2. 指数移动平均 (EMA)
```
EMA_t = α × x_t + (1 - α) × EMA_(t-1)

其中：
- α = 2 / (n + 1)
- n: 周期数（通常取7或30）
- x_t: 当期值
- EMA_(t-1): 上期EMA

EMA更重视近期数据，适合捕捉趋势变化
```

#### 3. 趋势强度 (Trend Strength)
```
趋势强度 = |当前值 - MA_30| / MA_30 × 100%

上升趋势: 当前值 > MA_30 且趋势强度 > 5%
下降趋势: 当前值 < MA_30 且趋势强度 > 5%
震荡: 趋势强度 <= 5%
```

#### 4. 环比增长率
```
环比增长率 = (当期 - 上期) / 上期 × 100%

异常增长: |环比增长率| > 50%
快速增长: 20% < 环比增长率 <= 50%
稳定增长: 5% < 环比增长率 <= 20%
平稳: |环比增长率| <= 5%
下降: 环比增长率 < -5%
```

#### 5. 波动率 (Volatility)
```
波动率 = 标准差 / 平均值 × 100%

低波动: 波动率 < 10%
中波动: 10% <= 波动率 < 30%
高波动: 波动率 >= 30%
```

---

### 3.6 用户留存分析

#### 1. N日留存率
```
N日留存率 = 第N日活跃用户数 / 首日新增用户数 × 100%

次日留存: N = 1
7日留存: N = 7
30日留存: N = 30
```

#### 2. 留存曲线拟合 (幂函数模型)
```
留存率(t) = a × t^b + c

其中：
- t: 天数
- a, b, c: 拟合参数
- b通常为负数，表示留存率随时间递减
```

#### 3. 流失概率预测 (逻辑回归)
```
P(流失) = 1 / (1 + e^(-z))

z = β₀ + β₁×最近消费天数 + β₂×消费频次 + β₃×消费金额 + β₄×活跃度

流失预警阈值:
- 高风险: P(流失) > 0.7
- 中风险: 0.4 < P(流失) <= 0.7
- 低风险: P(流失) <= 0.4
```

---

### 3.7 主播多维度评估雷达图

#### 评估维度与计算

**1. 收入能力 (Income)**
```
收入得分 = MIN(月收入 / 10000, 10)
满分10分，每1万元得1分
```

**2. 粉丝质量 (Fan Quality)**
```
粉丝质量 = (付费粉丝数 / 总粉丝数) × 10
付费转化率越高，粉丝质量越好
```

**3. 互动能力 (Engagement)**
```
互动得分 = 归一化(弹幕数 + 点赞数 + 打赏次数) × 10
```

**4. 收入稳定性 (Stability)**
```
稳定性得分 = (1 - CV) × 10
CV: 变异系数，越小越稳定
```

**5. 增长潜力 (Growth)**
```
增长得分 = MIN(月增长率 / 10%, 10)
满分10分，每10%增长得1分
```

**雷达图数据格式**
```json
{
  "anchorId": 123,
  "anchorName": "主播A",
  "dimensions": {
    "income": 7.5,
    "fanQuality": 6.2,
    "engagement": 8.3,
    "stability": 7.8,
    "growth": 9.1
  },
  "overallScore": 7.78
}
```

---

## 四、异步分析框架设计

### 4.1 框架架构

```
触发层 (Trigger Layer)
    ├─ 定时触发 (Scheduled)
    ├─ 事件触发 (Event-Driven)
    └─ 手动触发 (Manual)
    ↓
调度层 (Scheduler Layer)
    ├─ 任务队列管理
    ├─ 优先级调度
    └─ 并发控制
    ↓
执行层 (Execution Layer)
    ├─ 数据提取 (Extract from DB1, DB2)
    ├─ 数据转换 (Transform & Calculate)
    └─ 数据加载 (Load to Cache/DB)
    ↓
存储层 (Storage Layer)
    ├─ MySQL (持久化)
    ├─ Redis (热数据缓存)
    └─ ElasticSearch (可选，高级搜索)
    ↓
展示层 (Presentation Layer)
    ├─ RESTful API
    ├─ WebSocket (实时推送)
    └─ 前端图表渲染
```

---

### 4.2 任务调度设计

#### 1. 定时任务 (Cron Jobs)

**高频任务（每小时）**
```
0 0 * * * *  # 小时统计任务
- 汇总上一小时的打赏数据
- 更新 hourly_statistics 表
- 清理过期Redis缓存
```

**中频任务（每天）**
```
0 2 * * *  # 日统计任务（凌晨2点）
- 计算昨日GMV、ARPU、ARPPU
- 更新观众画像
- 计算主播收入排行
- 生成日报数据

0 3 * * *  # 留存分析任务（凌晨3点）
- 计算次日/7日/30日留存
- 更新流失预警名单

0 4 * * *  # 标签关联度计算（凌晨4点）
- 重新计算标签共现矩阵
- 更新 tag_relation 表
```

**低频任务（每周/月）**
```
0 5 * * 1  # 周统计任务（周一凌晨5点）
- 计算上周数据汇总
- 生成周报

0 6 1 * *  # 月统计任务（每月1日凌晨6点）
- 计算上月数据汇总
- 生成月报
- LTV模型重训练
```

#### 2. 事件触发任务

**触发条件**
```java
@EventListener
public void onRechargeEvent(RechargeEvent event) {
    // 实时更新主播收入
    // 实时更新直播间热度
    // 异步计算观众画像增量
}

@EventListener
public void onSettlementEvent(SettlementEvent event) {
    // 更新结算状态
    // 触发财务报表生成
}
```

---

### 4.3 数据管道 (Data Pipeline)

#### Pipeline 1: 打赏数据聚合

```
DB1.recharge (原始打赏记录)
    ↓ Extract
    ├─ 按小时分组聚合
    ├─ 按主播ID聚合
    ├─ 按观众ID聚合
    └─ 按标签分组聚合
    ↓ Transform
    ├─ 计算统计指标（SUM, AVG, COUNT, MAX, MIN）
    ├─ 计算百分位数（P50, P80, P95）
    └─ 计算增长率
    ↓ Load
    ├─ DB2.hourly_statistics
    ├─ Redis缓存 (TTL: 24h)
    └─ 消息队列 (通知订阅者)
```

#### Pipeline 2: 观众画像计算

```
数据源:
    ├─ DB1.recharge (消费行为)
    ├─ DB1.audience (基础信息)
    ├─ DB1.audience_tag (标签)
    └─ DB1.live_session_audience (观看行为)
    ↓ Extract & Join
    ├─ 消费数据: 总金额、频次、最近消费时间
    ├─ 行为数据: 观看时长、互动次数
    └─ 标签数据: 偏好标签、权重
    ↓ Transform
    ├─ 计算RFM得分
    ├─ 计算活跃度
    ├─ 计算消费分位数
    ├─ 预测LTV
    └─ 生成画像描述
    ↓ Load
    ├─ DB2.audience_portrait
    └─ Redis缓存 (TTL: 12h)
```

#### Pipeline 3: 标签热力图生成

```
数据源:
    ├─ DB1.anchor_tag
    ├─ DB1.audience_tag
    └─ DB1.live_room_tag
    ↓ Extract
    ├─ 提取所有用户-标签关系
    └─ 构建标签共现矩阵
    ↓ Transform
    ├─ 计算Jaccard相似度
    ├─ 计算共现频率
    ├─ 评估关联强度
    └─ 生成对称矩阵
    ↓ Load
    ├─ DB1.tag_relation (持久化)
    ├─ Redis缓存 (TTL: 7天)
    └─ JSON文件 (前端直接加载)
```

---

### 4.4 缓存策略

#### Redis缓存键设计

```
# 主播收入缓存
analysis:anchor:income:{anchorId}:{period}
TTL: 1小时 (实时性要求高)

# 观众画像缓存
analysis:audience:portrait:{audienceId}
TTL: 12小时 (中等实时性)

# 标签热力图缓存
analysis:tag:heatmap:matrix
TTL: 7天 (实时性要求低)

# 排行榜缓存
analysis:ranking:anchor:income:{period}
TTL: 30分钟 (高并发读取)

# 统计数据缓存
analysis:statistics:gmv:{date}
TTL: 24小时 (历史数据不变)
```

#### 缓存更新策略

**写穿策略 (Write-Through)**
```
新增打赏 → 同时写入MySQL和Redis
优点: 数据一致性高
缺点: 写入延迟略高
```

**延迟双删策略 (Delayed Double Delete)**
```
1. 更新MySQL
2. 删除缓存
3. 延迟500ms
4. 再次删除缓存
优点: 解决并发脏读问题
```

---

### 4.5 并发控制与限流

#### 1. 任务互斥锁 (Distributed Lock)

```java
// Redis分布式锁
String lockKey = "analysis:lock:hourly_statistics";
boolean acquired = redisTemplate.opsForValue()
    .setIfAbsent(lockKey, "1", 10, TimeUnit.MINUTES);

if (acquired) {
    try {
        // 执行统计任务
        processHourlyStatistics();
    } finally {
        redisTemplate.delete(lockKey);
    }
}
```

#### 2. 限流策略 (Rate Limiting)

**滑动窗口限流**
```
限制条件:
- 每秒最多10个分析请求
- 每分钟最多100个分析请求
- 每小时最多1000个分析请求

实现: Redis + Lua脚本
```

**令牌桶算法**
```
桶容量: 100
令牌生成速率: 10个/秒
突发流量: 允许瞬间消耗所有令牌
```

---

### 4.6 异常处理与重试机制

#### 1. 重试策略

```
指数退避 (Exponential Backoff):
    第1次重试: 延迟 1秒
    第2次重试: 延迟 2秒
    第3次重试: 延迟 4秒
    第4次重试: 延迟 8秒
    最大重试次数: 5次
    超时失败: 写入死信队列
```

#### 2. 降级策略

```
当数据库查询超时或失败:
    1. 返回缓存数据（即使过期）
    2. 返回默认值
    3. 返回部分数据
    4. 告知用户稍后重试
```

---

## 五、SQL查询示例

### 5.1 主播收入TOP10查询

```sql
-- 查询本月主播收入TOP10
SELECT 
    r.anchor_id,
    r.anchor_name,
    COUNT(*) as recharge_count,
    COUNT(DISTINCT r.audience_id) as unique_payers,
    SUM(r.recharge_amount) as total_amount,
    SUM(r.settlement_amount) as total_income,
    AVG(r.recharge_amount) as avg_amount,
    MAX(r.recharge_amount) as max_amount
FROM recharge_record r
WHERE r.recharge_time >= DATE_FORMAT(NOW(), '%Y-%m-01')
  AND r.recharge_time < DATE_ADD(DATE_FORMAT(NOW(), '%Y-%m-01'), INTERVAL 1 MONTH)
GROUP BY r.anchor_id, r.anchor_name
ORDER BY total_income DESC
LIMIT 10
```

### 5.2 观众消费分层查询

```sql
-- 计算观众消费分层（高/中/低）
SELECT 
    consumption_level,
    COUNT(*) as user_count,
    SUM(total_recharge_amount) as total_amount,
    AVG(total_recharge_amount) as avg_amount,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM audience), 2) as percentage
FROM audience
GROUP BY consumption_level
ORDER BY consumption_level DESC
```

### 5.3 标签关联度查询

```sql
-- 查询与指定标签最相关的TOP10标签
SELECT 
    t2.tag_name,
    tr.relation_score,
    tr.cooccurrence_count,
    tr.strength_level,
    CASE tr.strength_level
        WHEN 3 THEN '强关联'
        WHEN 2 THEN '中关联'
        ELSE '弱关联'
    END as strength_desc
FROM tag_relation tr
INNER JOIN tag t1 ON tr.tag_id1 = t1.tag_id
INNER JOIN tag t2 ON tr.tag_id2 = t2.tag_id
WHERE t1.tag_name = '游戏'
ORDER BY tr.relation_score DESC
LIMIT 10
```

### 5.4 时段热力图数据查询

```sql
-- 查询一周内每小时的打赏活跃度（用于生成热力图）
SELECT 
    DAYOFWEEK(recharge_time) as day_of_week,
    HOUR(recharge_time) as hour_of_day,
    COUNT(*) as recharge_count,
    SUM(recharge_amount) as total_amount,
    COUNT(DISTINCT audience_id) as unique_payers
FROM recharge
WHERE recharge_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY day_of_week, hour_of_day
ORDER BY day_of_week, hour_of_day
```

### 5.5 主播收入趋势查询

```sql
-- 查询主播最近30天的收入趋势（含移动平均）
SELECT 
    DATE(recharge_time) as date,
    SUM(settlement_amount) as daily_income,
    AVG(SUM(settlement_amount)) OVER (
        ORDER BY DATE(recharge_time)
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as ma_7,
    AVG(SUM(settlement_amount)) OVER (
        ORDER BY DATE(recharge_time)
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) as ma_30
FROM recharge_record
WHERE anchor_id = 123
  AND recharge_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY DATE(recharge_time)
ORDER BY date
```

---

## 六、性能优化策略

### 6.1 数据库优化

#### 1. 索引优化
```sql
-- 复合索引（覆盖常用查询）
CREATE INDEX idx_recharge_time_anchor ON recharge_record(recharge_time, anchor_id);
CREATE INDEX idx_audience_consumption ON audience(consumption_level, total_recharge_amount);
CREATE INDEX idx_tag_relation_score ON tag_relation(relation_score, strength_level);
```

#### 2. 分区表（大数据量场景）
```sql
-- 按月分区
ALTER TABLE recharge_record 
PARTITION BY RANGE (YEAR(recharge_time) * 100 + MONTH(recharge_time)) (
    PARTITION p202601 VALUES LESS THAN (202602),
    PARTITION p202602 VALUES LESS THAN (202603),
    ...
);
```

#### 3. 物化视图（预聚合）
```sql
-- 创建主播日收入物化视图
CREATE TABLE mv_anchor_daily_income AS
SELECT 
    anchor_id,
    DATE(recharge_time) as date,
    SUM(settlement_amount) as income,
    COUNT(*) as recharge_count
FROM recharge_record
GROUP BY anchor_id, DATE(recharge_time);

-- 每日更新
INSERT INTO mv_anchor_daily_income ...
```

---

### 6.2 查询优化

#### 1. 读写分离
```
写操作 → 主库 (Master)
读操作 → 从库 (Slave)
分析查询 → 只读从库 (避免影响主库性能)
```

#### 2. 批量查询
```
单次查询改为批量:
- 100次单条查询 → 1次批量查询
- 减少网络往返次数
```

#### 3. 结果缓存
```
频繁查询结果缓存到Redis:
- TOP10榜单: 30分钟更新一次
- 统计数据: 1小时更新一次
```

---

## 七、监控与告警

### 7.1 监控指标

```
系统指标:
- 任务执行时长
- 任务成功率
- 数据库查询响应时间
- Redis命中率
- 内存使用率

业务指标:
- 每日GMV
- 付费用户数
- ARPU / ARPPU
- 主播平均收入
- 观众留存率
```

### 7.2 告警规则

```
P0 (紧急):
- 定时任务连续失败3次
- 数据库连接池耗尽
- Redis不可用

P1 (重要):
- 任务执行时长超过阈值1倍
- 数据同步延迟超过1小时
- 缓存命中率 < 70%

P2 (一般):
- GMV同比下降 > 20%
- 观众留存率环比下降 > 10%
```

---

## 八、扩展性设计

### 8.1 水平扩展

```
增加分析节点:
- 多个分析服务实例
- 负载均衡
- 任务分片执行
```

### 8.2 数据分片

```
按主播ID分片:
- 主播ID % 10 → 分片0-9
- 每个分片独立计算
- 最后汇总结果
```

---

## 九、API接口设计

### 9.1 查询接口

```
GET /api/v1/analysis/anchor/{anchorId}/income
    ?period=day|week|month
    返回: 主播收入数据

GET /api/v1/analysis/audience/{audienceId}/portrait
    返回: 观众画像

GET /api/v1/analysis/tag/heatmap
    返回: 标签热力图矩阵

GET /api/v1/analysis/statistics/gmv
    ?startDate=2026-01-01&endDate=2026-01-31
    返回: 平台GMV趋势

GET /api/v1/analysis/ranking/anchor
    ?type=income&period=month&limit=10
    返回: 主播排行榜
```

### 9.2 触发接口

```
POST /api/v1/analysis/trigger/hourly-statistics
    手动触发小时统计任务

POST /api/v1/analysis/trigger/audience-portrait
    手动触发观众画像计算

POST /api/v1/analysis/trigger/tag-relation
    手动触发标签关联度计算
```

---

## 十、总结

本数据分析模块设计涵盖：

✅ **10种图表类型** - 全面展示数据分析结果  
✅ **30+核心指标** - 覆盖财务、用户、内容三大维度  
✅ **异步分析框架** - 高性能、可扩展、易维护  
✅ **标签热力图算法** - Jaccard相似度 + 共现频率  
✅ **流水变化趋势** - 移动平均 + EMA + 波动率  
✅ **观众数据分析** - RFM模型 + LTV预测 + 留存分析  
✅ **主播收入分析** - 多维度评估 + 雷达图展示  

**设计原则**：
1. 高性能：Redis缓存 + 物化视图 + 索引优化
2. 高可用：分布式锁 + 重试机制 + 降级策略
3. 易扩展：任务分片 + 数据分片 + 水平扩展
4. 易维护：日志监控 + 告警机制 + 文档完善

---

**文档维护者**: Team  
**最后更新**: 2026-01-02
